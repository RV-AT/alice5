Implementation Notes

All Pointer types have a "StorageClass"; like "Uniform" for objects passed in from the application, "Input" objects created by the rasterizer for a single invocation of the fragment shader, or "Output" objects stored into by the shader for use later in the pipeline (like output fragment colors), among other storage classes.  I've chosen to have a flat memory space for simplicity, but a hardware implementation probably would need separate memory spaces with varying degrees of write protection and caching.  Separate instances of the shader would also need to have private instances of Input and Output generated by the invoker before calling the shader and then gathered by the invoker afterwards, e.g. for storing into a framebuffer.

ShaderToy builtins:

uniform vec3      iResolution;           // viewport resolution (in pixels)
uniform float     iTime;                 // shader playback time (in seconds)
uniform float     iTimeDelta;            // render time (in seconds)
uniform int       iFrame;                // shader playback frame
uniform float     iChannelTime[4];       // channel playback time (in seconds)
uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)
uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click
uniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cube
uniform vec4      iDate;                 // (year, month, day, time in seconds)
uniform float     iSampleRate;           // sound sample rate (i.e., 44100)
