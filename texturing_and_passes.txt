implement 
    inputs can also be structs. (we probably won't have any though.)
    uniforms can be structs of structs, and the offset of elements is relative to the inner struct
    make new functions
        interpreter.setUniform(const std::string& name, const T& v)
        interpreter.setInput(std::string& name, const T& v);
    interpreter.setUniform("iResolution", v2float {static_cast<float>(output->width), static_cast<float>(output->height)});
    interpreter.setUniform("iChannel0", SampledImage {image[0], sampler[0]})
    interpreter.setInput("fragCoord", v2float {x, y}); // fragCoord is in #0 in preamble
    fail if path doesn't resolve to a vector or scalar or Image or Sampler or SampledImage?
    fail if size of constituent doesn't match size of passed value
    need to know for inputs
        mapping of names to locations
        mapping of locations to memory addresses
    need to know for uniforms
        mapping of names to binding point and offsets
        mapping of binding point to location in uniform memory
        size of uniform constituent for asserting sizes match
    on postParse, for every variable in uniform storage
        recursively descend constituents, constructing name and adding offsets from type sizes
            set location from variable allocated and offset
            store full name and memory address

                              Name 51  "fragCoord"
                              Name 49  "color"
                              Name 53  "param"
                              Name 59  "params"
                              MemberName 59(params) 0  "iResolution"
                              Name 61  ""
                              Decorate 49(color) Location 0
                              Decorate 51(fragCoord) Location 0
                              MemberDecorate 59(params) 0 Offset 0
                              Decorate 59(params) Block
                              Decorate 61 DescriptorSet 0
                              Decorate 61 Binding 0
               6:             TypeFloat 32
              12:             TypeVector 6(float) 4
              14:             TypeVector 6(float) 2
              15:             TypePointer Function 14(fvec2)
              48:             TypePointer Output 12(fvec4)
       49(color):     48(ptr) Variable Output
              50:             TypePointer Input 14(fvec2)
   51(fragCoord):     50(ptr) Variable Input
              58:             TypeVector 57(int) 4
      59(params):             TypeStruct 14(fvec2) 6(float) 58(ivec4)
              60:             TypePointer Uniform 59(params)
              61:     60(ptr) Variable Uniform
       53(param):     15(ptr) Variable Function
              50:             TypePointer Input 14(fvec2)
   51(fragCoord):     50(ptr) Variable Input

        61 (has no name) is a uniform variable of type 60-pointer, which points to a 59 (we can know size from type 59)
            61 is descriptorset 0 (ignore)
            61 is binding 0 (so we can map binding 0 to address from alloc)
            61 has no name, so its children are top-level variables?
                so 61 cannot be set directly.
            type 59's members 0, 1, and 2 are iResolution, iTime, and iMouse
                their offsets are 0, 8, and 16
                so we don't need to know alignment requirements if setting vector/scalar values?
Parse JSON into Pass, Image, Sampler
    test dump from multipass shader (wall effect?)
Use Passes correctly
    try a BUNCH of shaders
Pixel kill?
Test C64
Implement Sampler and sample()
    test on single texture input


// Module Version 10300
// Generated by (magic number): 80007
// Id's are bound by 44

                              Capability Shader
               1:             ExtInstImport  "GLSL.std.450"
                              MemoryModel Logical GLSL450
                              EntryPoint Fragment 4  "main" 36 38
                              ExecutionMode 4 OriginUpperLeft
                              Source GLSL 450
                              Name 4  "main"
                              Name 14  "mainImage(vf4;vf2;"
                              Name 12  "fragColor"
                              Name 13  "fragCoord"
                              Name 16  "uv"
                              Name 20  "params"
                              MemberName 20(params) 0  "iResolution"
                              MemberName 20(params) 1  "iTime"
                              MemberName 20(params) 2  "iMouse"
                              Name 22  ""
                              Name 31  "iChannel0"
                              Name 36  "color"
                              Name 38  "fragCoord"
                              Name 39  "param"
                              Name 40  "param"
                              MemberDecorate 20(params) 0 Offset 0
                              MemberDecorate 20(params) 1 Offset 8
                              MemberDecorate 20(params) 2 Offset 16
                              Decorate 20(params) Block
                              Decorate 22 DescriptorSet 0
                              Decorate 22 Binding 1
                              Decorate 31(iChannel0) DescriptorSet 0
                              Decorate 31(iChannel0) Binding 0
                              Decorate 36(color) Location 0
                              Decorate 38(fragCoord) Location 0
               2:             TypeVoid
               3:             TypeFunction 2
               6:             TypeFloat 32
               7:             TypeVector 6(float) 4
               8:             TypePointer Function 7(fvec4)
               9:             TypeVector 6(float) 2
              10:             TypePointer Function 9(fvec2)
              11:             TypeFunction 2 8(ptr) 10(ptr)
              18:             TypeInt 32 1
              19:             TypeVector 18(int) 4
      20(params):             TypeStruct 9(fvec2) 6(float) 19(ivec4)
              21:             TypePointer Uniform 20(params)
              22:     21(ptr) Variable Uniform

              23:     18(int) Constant 0
              24:             TypePointer Uniform 9(fvec2)
              28:             TypeImage 6(float) 2D sampled format:Unknown
              29:             TypeSampledImage 28
              30:             TypePointer UniformConstant 29
   31(iChannel0):     30(ptr) Variable UniformConstant
                                follow decorations so that 31 points to 
              35:             TypePointer Output 7(fvec4)
       36(color):     35(ptr) Variable Output
              37:             TypePointer Input 9(fvec2)
   38(fragCoord):     37(ptr) Variable Input
         4(main):           2 Function None 3
               5:             Label
       39(param):      8(ptr) Variable Function
       40(param):     10(ptr) Variable Function
              41:    9(fvec2) Load 38(fragCoord)
                              Store 40(param) 41
              42:           2 FunctionCall 14(mainImage(vf4;vf2;) 39(param) 40(param)
              43:    7(fvec4) Load 39(param)
                              Store 36(color) 43
                              Return
                              FunctionEnd
14(mainImage(vf4;vf2;):           2 Function None 11
   12(fragColor):      8(ptr) FunctionParameter
   13(fragCoord):     10(ptr) FunctionParameter
              15:             Label
          16(uv):     10(ptr) Variable Function
              17:    9(fvec2) Load 13(fragCoord)
              25:     24(ptr) AccessChain 22 23
              26:    9(fvec2) Load 25
              27:    9(fvec2) FDiv 17 26
                              Store 16(uv) 27
              32:          29 Load 31(iChannel0)
                                load image* through 31
              33:    9(fvec2) Load 16(uv)
              34:    7(fvec4) ImageSampleImplicitLod 32 33
                                dereference image* in 32
                              Store 12(fragColor) 34
                              Return
                              FunctionEnd

              22:     21(ptr) Variable Uniform
22 is a pointer of type 21 to a thing in storage class Uniform
    21 is a pointer to type 20 
        type 20 is a TypeStruct (containing our struct params from uniforms)
        type 20 is named "params"
        member 0 of 20 is MemberNamed as "iResolution" and MemberDecorated as being at offset 0
        member 1 of 20 is MemberNamed as "iTime" and MemberDecorated as being at offset 8
        member 2 of 20 is MemberNamed as "iMouse" and MemberDecorated as being at offset 16
    pointer 22 is decorated as being in DescriptorSet 0 and Binding 0
    I want something like "getBindingLocation(const std::string& name)"
    and "getMemberOffset(const std::string& name, const std::string& member, ...)"

ImageSampleImplicitLod on sampledImage 32, coordinate 33
    sampledImage32 is loaded through pointer 31, type 29
        type 29 is TypeSampledImage on type 28
              type 28 is a TypeImage, returning 6(float), 2D, sampled, format:Unknown
        pointer 31 is of type 30 and points to storage class UniformConstant
            pointer 31 is named "iChannel0"
            pointer 31 is decorated as being in DescriptorSet 0 and Binding 1
            type 30 is pointer to type 29 in storage class UniformConstant
                (see type 29 above)
        So 31 points to a SampledImage at Binding 1 in Uniform Constant memory called "iChannel"
Therefore
    Variable allocates space at UniformConstant binding
    initialization of Program sets sampledImages[] from RenderPass::inputs[]
    rendering sets index in Program::sampledImages[] into the variable
    contents of samplerId in stepImageSampleImplicitLod is the index to read image from sampledImages

If the contents of TypeImage is an Image*, and the contents of TypeSampler is a Sampler* (both populated by the app), then TypeSampledImage would be a struct {Image*; Sampler*}, and you could set the thing from render() and know which image to sample from stepImageSampleImplicitLod.
