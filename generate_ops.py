
# Generates C++ include files for the SPIR-V instructions.

import sys
import json
import re

WARNING = "// Automatically generated by generate_ops.py. DO NOT EDIT.\n\n"
IMPL_RE = re.compile(r"void step(.*)\(const Insn(.*)& insn\)")

def CamelCase_to_camelCase(name):
    return name[0].lower() + name[1:]

# Clean up a name like "'Sampled Image'" to "sampledImage".
def cleanUpName(name):
    if "," in name:
        return "operand"
    else:
        return CamelCase_to_camelCase(name[1:-1].replace(" ", "").replace("~", ""))

# Figure out what instructions are already implemented.
def get_already_implemented_instructions(source_pathname):
    lines = open(source_pathname).readlines()

    already_implemented = set()

    for line in lines:
        m = IMPL_RE.match(line.strip())
        if m:
            # Make sure the function name and parameter match.
            name1 = m.group(1)
            name2 = m.group(2)
            assert(name1 == name2)

            already_implemented.add(name1)

    return already_implemented

def main():
    # Input file.
    json_pathname = sys.argv[1]
    grammar = json.load(open(json_pathname))

    # Create map from operand kind name ("FPFastMathMode") to info about the kind.
    operand_kind_map = dict((kind["kind"], kind) for kind in grammar["operand_kinds"])

    # Find what instructions have already been implemented.
    already_implemented = get_already_implemented_instructions("shade.cpp")

    # Output files.
    opcode_to_string_f = open("opcode_to_string.h", "w")
    opcode_to_string_f.write(WARNING);

    opcode_structs_f = open("opcode_structs.h", "w")
    opcode_structs_f.write(WARNING);

    opcode_variant_f = open("opcode_variant.h", "w")
    opcode_variant_f.write(WARNING);
    variant_entries = []

    opcode_dispatch_f = open("opcode_dispatch.h", "w")
    opcode_dispatch_f.write(WARNING);

    opcode_impl_f = open("opcode_impl.h", "w")
    opcode_impl_f.write(WARNING);

    for instruction in grammar["instructions"]:
        opcode = instruction["opcode"]
        opname = instruction["opname"]
        if not opname.startswith("Op"):
            sys.stderr.write("Instruction name \"%s\" does not start with \"Op\".\n" % opname);
            sys.exit(1)

        short_opname = opname[2:]
        struct_opname = "Insn" + short_opname

        opcode_to_string_f.write("    {%d, \"%s\"},\n" % (opcode, short_opname))

        opcode_structs_f.write("// %s instruction (code %d).\n" % (opname, opcode))
        opcode_structs_f.write("struct %s {\n" % (struct_opname, ))
        for operand in instruction.get("operands", []):
            kind = operand["kind"]
            name = operand.get("name")
            quantifier = operand.get("quantifier")

            cpp_type = "uint32_t"
            cpp_name = cleanUpName(name) + "Id" if name else None

            if kind == "IdResultType":
                assert(not name)
                cpp_name = "type"
                cpp_comment = "result type"
            elif kind == "IdResult":
                assert(not name)
                cpp_name = "resultId"
                cpp_comment = "SSA register for result value"
            elif kind == "IdRef":
                assert(name)
                cpp_comment = "operand from register"
            elif kind == "LiteralString":
                cpp_type = "std::string"
                cpp_comment = "literal string"
            else:
                operand_kind = operand_kind_map[kind]
                category = operand_kind["category"]
                if category in ["Literal", "Composite", "Id"]:
                    # We've already handled literal strings above. All
                    # composites and IDs are integers.
                    assert(cpp_name)
                    cpp_comment = kind
                elif category in ["ValueEnum", "BitEnum"]:
                    # Keep uint32_t.
                    if not cpp_name:
                        cpp_name = CamelCase_to_camelCase(kind)
                    cpp_comment = kind
                else:
                    sys.stderr.write("Unhandled kind \"%s\" for operator \"%s\".\n" % (kind, opname))
                    sys.exit(1)

            # Varargs.
            if quantifier == "*":
                cpp_type = "std::vector<" + cpp_type + ">"

            opcode_structs_f.write("    %s %s; // %s%s\n" % (cpp_type, cpp_name, cpp_comment, " (optional)" if quantifier == "?" else ""));
        opcode_structs_f.write("};\n\n")

        # Takes too long to compile if you add them all.
        if short_opname in already_implemented:
            variant_entries.append(struct_opname)
            opcode_dispatch_f.write("[&](const %s& insn) { step%s(insn); },\n" % (struct_opname, short_opname))

        # Generate a stub if it's not already implemented in the C++ file.
        if short_opname not in already_implemented:
            opcode_impl_f.write("    void step%s(const Insn%s& insn)\n    {\n        std::cerr << \"step%s() not implemented\\n\";\n    }\n\n"
                    % (short_opname, short_opname, short_opname))

    opcode_variant_f.write(",\n".join(variant_entries))

    opcode_to_string_f.close()
    opcode_structs_f.close()
    opcode_variant_f.close()
    opcode_dispatch_f.close()
    opcode_impl_f.close()

if __name__ == "__main__":
    main()

