
# Generates C++ include files for the SPIR-V instructions.

import sys
import json

WARNING = "// Automatically generated by generate_ops.py. DO NOT EDIT.\n\n"

def CamelCase_to_camelCase(name):
    return name[0].lower() + name[1:]

# Clean up a name like "'Sampled Image'" to "sampledImage".
def cleanUpName(name):
    if "," in name:
        return "operand"
    else:
        return CamelCase_to_camelCase(name[1:-1].replace(" ", "").replace("~", ""))

def main():
    # Input file.
    json_pathname = sys.argv[1]
    grammar = json.load(open(json_pathname))

    # Create map from operand kind name ("FPFastMathMode") to info about the kind.
    operand_kind_map = dict((kind["kind"], kind) for kind in grammar["operand_kinds"])

    # Output files.
    opcode_to_string_f = open("opcode_to_string.h", "w")
    opcode_to_string_f.write(WARNING);

    opcode_structs_f = open("opcode_structs.h", "w")
    opcode_structs_f.write(WARNING);

    for instruction in grammar["instructions"]:
        opcode = instruction["opcode"]
        opname = instruction["opname"]
        if not opname.startswith("Op"):
            sys.stderr.write("Instruction name \"%s\" does not start with \"Op\".\n" % opname);
            sys.exit(1)

        short_opname = opname[2:]

        opcode_to_string_f.write("    {%d, \"%s\"},\n" % (opcode, short_opname))

        opcode_structs_f.write("// %s instruction (code %d).\n" % (opname, opcode))
        opcode_structs_f.write("struct Insn%s {\n" % (short_opname, ))
        for operand in instruction.get("operands", []):
            kind = operand["kind"]
            name = operand.get("name")
            quantifier = operand.get("quantifier")

            cpp_type = "uint32_t"
            cpp_name = cleanUpName(name) + "Id" if name else None

            if kind == "IdResultType":
                assert(not name)
                cpp_name = "type"
                cpp_comment = "result type"
            elif kind == "IdResult":
                assert(not name)
                cpp_name = "resultId"
                cpp_comment = "SSA register for result value"
            elif kind == "IdRef":
                assert(name)
                cpp_comment = "operand from register"
            elif kind == "LiteralString":
                cpp_type = "std::string"
                cpp_comment = "literal string"
            else:
                operand_kind = operand_kind_map[kind]
                category = operand_kind["category"]
                if category in ["Literal", "Composite", "Id"]:
                    # We've already handled literal strings above. All
                    # composites and IDs are integers.
                    assert(cpp_name)
                    cpp_comment = kind
                elif category in ["ValueEnum", "BitEnum"]:
                    # Keep uint32_t.
                    if not cpp_name:
                        cpp_name = CamelCase_to_camelCase(kind)
                    cpp_comment = kind
                else:
                    sys.stderr.write("Unhandled kind \"%s\" for operator \"%s\".\n" % (kind, opname))
                    sys.exit(1)

            # Varargs.
            if quantifier == "*":
                cpp_type = "std::vector<" + cpp_type + ">"

            opcode_structs_f.write("    %s %s; // %s%s\n" % (cpp_type, cpp_name, cpp_comment, " (optional)" if quantifier == "?" else ""));
        opcode_structs_f.write("};\n\n")

    opcode_to_string_f.close()
    opcode_structs_f.close()

if __name__ == "__main__":
    main()

#struct InsnFMul {
#    uint32_t type;
#
#    // SSA register to write result to.
#    uint32_t resultId;
#    uint32_t operand1Id;
#    uint32_t operand2Id;
#};
#
#    {
#      "opname" : "OpFMul",
#      "opcode" : 133,
#      "operands" : [
#        { "kind" : "IdResultType" },
#        { "kind" : "IdResult" },
#        { "kind" : "IdRef",        "name" : "'Operand 1'" },
#        { "kind" : "IdRef",        "name" : "'Operand 2'" }
#      ]
#    },
